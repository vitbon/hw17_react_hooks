{"version":3,"sources":["logo.svg","timer/teddy_alert.mp3","App.js","timer/timer.js","serviceWorker.js","index.js"],"names":["module","exports","App","Timer","state","from","interval","beginDate","Date","now","autoStart","infinity","pause","action","waitingDate","electron","startButton","intervalID","circleSVG","strokeDashoffset","strokeDasharray","Math","PI","componentDidMount","setState","props","calcElectron","initClock","componentWillUnmount","clearInterval","onTimeEnd","console","log","onTimeStart","onTimePause","a","setInterval","blinkingElectron","ele","tempTime","init","undefined","calcTime","toFixed","toString","abs","pos","timer","document","getElementById","currentTime","play","blinkID","countDownButton","e","checkValue","target","value","intervalButton","className","version","xmlns","cx","cy","r","style","this","onClick","out","id","type","min","max","onChange","preload","src","teddyAlarm","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3e05c4a2.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","module.exports = __webpack_public_path__ + \"static/media/teddy_alert.f23c27e5.mp3\";","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React, {Component} from \"react\";\r\nimport \"./timer.css\";\r\nimport teddyAlarm from \"./teddy_alert.mp3\";\r\n\r\nexport default class Timer extends Component {\r\n  state = {\r\n    from: 4,                 // countdown time\r\n    interval: 100,           // interval\r\n    beginDate: Date.now(),   // begin Date.now()\r\n    autoStart: false,\r\n    infinity: true,          // infinity circle\r\n    pause: false,            // paused State\r\n    action: false,           // is timer work?\r\n    waitingDate: 0,          // paused Date\r\n    electron: '00',\r\n    startButton: 'Start',\r\n    intervalID: 0,           // global Timer callback\r\n    circleSVG: {\r\n      strokeDashoffset: \"0\",\r\n      strokeDasharray: 2 * Math.PI * 100\r\n    },\r\n  };\r\n\r\n  componentDidMount = () => {\r\n    this.setState({from: this.props.from});\r\n    this.setState({interval: this.props.interval});\r\n    this.setState({infinity: this.props.infinity});\r\n    this.setState({autoStart: this.props.autoStart});\r\n    this.calcElectron(this.props.from);\r\n    if (this.props.autoStart) this.initClock();\r\n  };\r\n\r\n  componentWillUnmount = () => {\r\n    clearInterval(this.intervalID);\r\n    this.setState({action: false});\r\n  };\r\n\r\n  onTimeEnd= () => console.log(\"Час вийшов!\");\r\n  onTimeStart=() => console.log(\"Таймер запущено!\");\r\n  onTimePause=() => console.log(\"Таймер на паузі!\");\r\n\r\n  initClock = async () => {\r\n    if (this.state.action && !this.state.pause) {  // resume start\r\n      this.onTimePause()\r\n      await this.setState({waitingDate: Date.now()});\r\n      await this.setState({startButton: \"Start\"});\r\n      await this.setState({pause: true});\r\n      clearInterval(this.state.intervalID);\r\n    } else {\r\n      if (this.state.action && this.state.pause) {  // resume end\r\n        await this.setState({waitingDate: Date.now() - this.state.waitingDate });\r\n        await this.setState({beginDate: this.state.beginDate + this.state.waitingDate });\r\n        await this.setState({waitingDate: 0 });\r\n        await this.setState({startButton: \"Pause\"});\r\n        await this.setState({pause: false});\r\n      } else { // init\r\n          this.onTimeStart();\r\n          await this.setState({beginDate: Date.now()});\r\n          await this.setState({startButton: \"Pause\"});\r\n          await this.setState({action: true});\r\n          await this.setState({pause: false});\r\n          await this.setState({circleSVG: {strokeDashoffset: 0}});\r\n        }\r\n      this.setState({\r\n        intervalID: setInterval(async () => {\r\n          this.calcElectron();\r\n          const curTime = Date.now() - this.state.beginDate;\r\n          if (curTime > this.state.from * 1000) {\r\n            this.onTimeEnd();\r\n            if (this.state.infinity) {\r\n               this.setState({beginDate: Date.now()});\r\n               this.setState({pause: 0});\r\n               this.setState({circleSVG: {strokeDashoffset: 0}});\r\n            } else {\r\n               clearInterval(this.state.intervalID);\r\n               this.setState({action: false});\r\n               this.setState({startButton: 'Start'});\r\n            }\r\n            await this.blinkingElectron();\r\n          }\r\n        }, this.state.interval),\r\n      });\r\n    }\r\n  };\r\n\r\n  calcElectron = (init= undefined) => {        // calculated electronic digits & SVG\r\n    let calcTime = init;\r\n    let ele;\r\n    let tempTime;\r\n    if (!init) {\r\n      tempTime = Date.now() - this.state.waitingDate - this.state.beginDate;\r\n      calcTime = (this.state.from - tempTime / 1000).toFixed();\r\n    }\r\n    ele = (calcTime >= 10) ? calcTime.toString() : '0' + Math.abs(calcTime);\r\n    if (this.state.action || init) this.setState({electron: ele});\r\n      else this.setState({electron: '00'});\r\n\r\n    const pos = (tempTime * 2 * Math.PI * 100 / this.state.from / 1000).toFixed();\r\n    this.setState({circleSVG: {strokeDashoffset: pos}});\r\n  };\r\n\r\n  blinkingElectron = () => {\r\n    let timer = 10;\r\n    this.setState({electron: '00'});\r\n    document.getElementById('alarm').currentTime = 0;\r\n    document.getElementById('alarm').play();\r\n    const blinkID = setInterval( () => {\r\n      (() => {\r\n        if (timer < 0) clearInterval(blinkID);\r\n        if (timer % 2) this.setState({circleSVG: {strokeDashoffset: 0}})\r\n        else this.setState({circleSVG: {strokeDashoffset: 2 * Math.PI * 100}});\r\n        timer--;\r\n      })();\r\n    }, 100);\r\n    this.calcElectron(this.state.from);\r\n  }\r\n\r\n  countDownButton = async(e) => {\r\n    let checkValue = +e.target.value;\r\n    if (checkValue > 99) checkValue = 99;\r\n    if (checkValue < 1) checkValue = 1;\r\n    await this.setState({from: checkValue});\r\n    this.calcElectron(this.state.from);\r\n  };\r\n\r\n  intervalButton = async (e) => {\r\n    let checkValue = +e.target.value;\r\n    if (checkValue > 9999) checkValue = 9999;\r\n    if (checkValue < 1) checkValue = 1;\r\n    await this.setState({interval: checkValue});\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"bg\">\r\n        <div className=\"container\">\r\n          <div className=\"count-down\">\r\n            <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\r\n              <circle className=\"stroke\"\r\n                      cx=\"110\" cy=\"110\" r=\"100\"\r\n                      style={this.state.circleSVG}\r\n              />\r\n            </svg>\r\n            <span className=\"digits\">88</span>\r\n            <span className=\"digits-overlay\" onClick={this.out}>\r\n              {this.state.electron}\r\n            </span>\r\n            <label className=\"inputCD\">\r\n              Timer (s):<br/>\r\n              <input id=\"countDown_btn\" type=\"number\" min=\"1\" max=\"99\"\r\n                     value={this.state.from}\r\n                     onChange={this.countDownButton}>\r\n              </input>\r\n            </label>\r\n            <label className=\"inputINT\">\r\n              Interval (ms):<br/>\r\n              <input id=\"interval_btn\" type=\"number\" min=\"1\" max=\"9999\"\r\n                     value={this.state.interval}\r\n                     onChange={this.intervalButton}>\r\n              </input>\r\n            </label>\r\n            <p className=\"auto_start\">{this.state.autoStart ? 'autostart' : ''}</p>\r\n            <p className=\"infinity\">{this.state.infinity ? 'infinity' : ''}</p>\r\n            <button className=\"start_btn\" onClick={this.initClock}>\r\n              {this.state.startButton}\r\n            </button>\r\n          </div>\r\n          <audio id='alarm' preload='auto' src={teddyAlarm}></audio>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\n\r\n// Завдання Basic:\r\n//   Ваше основне завдання у цій домашці: зробити таймер зворотнього відліку.\r\n//   Компонент <Timer /> Приклад того, що має бути: https://www.youtube.com/watch?v=Mxo0RE_bJO4\r\n// 1.\tТаймер повинен отримувати props time – час, з якого починається відлік\r\n// 2.\tУ таймера повинна бути кнопка start/pause. При натисканні на яку відповідно таймер або ставиться на паузу, або запускається знову\r\n// 3.\tПовинен бути props autostart автоматичного запуску. Якщо вказано true – таймер запускається сам. (componentDidMount може вам в цьому допомогти)\r\n// 4.\tВ компонент <Timer onTick={(time) => console.log(\"Залишилось часу: \" + time)} /> можна передавати функцію onTick, яка спрацьовує при кожному \"тіку\" таймера.\r\n// 5.\tДодайте props step, який дозволить передати інтервал оновлення таймера. Наприклад раз у 1 секунду/100 мс/2с/10с.\r\n// Зверніть увагу на відео – нижній таймер змінюється кожні 2 секунди. Всі значення часу у таймера вказані в мс\r\n// 6.\tДовжина полоски зменшується з рухом таймера(анімацію раджу зробити потім окремо, вона в цьому завданні НЕОБОВЯЗКОВА)\r\n//\r\n//\r\n// Завдання Advanced:\r\n//   1.\tДодайте подію onTimeEnd, передається як <Timer onTimeEnd={() => console.log(\"Час вийшов!\")} />\r\n// 2.\tДодайте подію onTimeStart, передається як <Timer onTimeStart={(timeLeft) => console.log(\"Таймер запущено!\")} />\r\n// 3.\tДодайте подію onTimePause, передається як <Timer onTimePause={(timeLeft) => console.log(\"Таймер на паузі!\")} />\r\n// 4.\t*Завдання з зірочкою або навіть з кількома*\r\n// Якщо змінюється зовнішній props time – ваш таймер повинен відреагувати.\r\n//   Давайте розглянемо таку задачу.\r\n//   У нас є компонент таймера (передбачається, що всі попередні пункти ДЗ виконано). Необхідно щоб він був нескінченним.\r\n//   Як тільки час закінчиться – запускаемо таймер по новій. Нижче закріплено приклад використання такого таймеру з логікою.\r\n//   Ваша задача допрацювати тільки компонент Timer.","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport Timer from \"./timer/timer.js\";\n\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    {/*<App />*/}\n    <Timer\n      autoStart={false}\n      infinity={false}\n      from={10}\n      interval={1000}\n    />\n\n    <Timer\n      autoStart={true}\n      infinity={false}\n      from={99}\n      interval={2000}\n    />\n\n    <Timer\n      autoStart={true}\n      infinity={true}\n      from={60}\n      interval={100}\n    />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}